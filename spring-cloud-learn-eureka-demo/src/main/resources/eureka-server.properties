#/**
#* Configuration information required by the eureka server to operate.
#*
#* <p>
#* Most of the required information is provided by the default configuration
#* {@link com.netflix.eureka.DefaultEurekaServerConfig}.
#*
#* Note that all configurations are not effective at runtime unless and
#* otherwise specified.
#* </p>
#*
#* @author Karthik Ranganathan
#*
#*/
#public interface EurekaServerConfig {

#spring cloud
#/**
#* @author Dave Syer
#*/
#@Data
#@ConfigurationProperties(EurekaServerConfigBean.PREFIX)
#public class EurekaServerConfigBean implements EurekaServerConfig, EurekaConstants {

#public static final String PREFIX = "eureka.server";
#private static final int MINUTES = 60 * 1000;

#/**
#* Gets the <em>AWS Access Id</em>. This is primarily used for
#* <em>Elastic IP Biding</em>. The access id should be provided with
#* appropriate AWS permissions to bind the EIP.
#*
#* @return
#*/
#String getAWSAccessId();
#eureka.server.aWSAccessId=

#/**
#* Gets the <em>AWS Secret Key</em>. This is primarily used for
#* <em>Elastic IP Biding</em>. The access id should be provided with
#* appropriate AWS permissions to bind the EIP.
#*
#* @return
#*/
#String getAWSSecretKey();
#eureka.server.aWSSecretKey=

#/**
#* Gets the number of times the server should try to bind to the candidate
#* EIP.
#*
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the number of times the server should try to bind to the
#*         candidate EIP.
#*/
#int getEIPBindRebindRetries();
#eureka.server.eIPBindRebindRetries = 3

#/**
#* Get the interval with which the server should check if the EIP is bound
#* and should try to bind in the case if it is already not bound, iff the EIP
#* is not currently bound.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the time in milliseconds.
#*/
#int getEIPBindingRetryIntervalMsWhenUnbound();
#eureka.server.eIPBindingRetryIntervalMsWhenUnbound = 1 * 60 * 1000;

#/**
#* Gets the interval with which the server should check if the EIP is bound
#* and should try to bind in the case if it is already not bound, iff the EIP
#* is already bound. (so this refresh is just for steady state checks)
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the time in milliseconds.
#*/
#int getEIPBindingRetryIntervalMs();
#eureka.server.eIPBindingRetryIntervalMs = 5 * 60 * 1000;

#/**
#* Checks to see if the eureka server is enabled for self preservation.
#*
#* <p>
#* When enabled, the server keeps track of the number of <em>renewals</em>
#* it should receive from the server. Any time, the number of renewals drops
#* below the threshold percentage as defined by
#* {@link #getRenewalPercentThreshold()}, the server turns off expirations
#* to avert danger.This will help the server in maintaining the registry
#* information in case of network problems between client and the server.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return true to enable self preservation, false otherwise.
#*/
#boolean shouldEnableSelfPreservation();
#eureka.server.enableSelfPreservation = true

#/**
#* The minimum percentage of renewals that is expected from the clients in
#* the period specified by {@link #getRenewalThresholdUpdateIntervalMs()}.
#* If the renewals drop below the threshold, the expirations are disabled if
#* the {@link #shouldEnableSelfPreservation()} is enabled.
#*
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return value between 0 and 1 indicating the percentage. For example,
#*         <code>85%</code> will be specified as <code>0.85</code>.
#*/
#double getRenewalPercentThreshold();
#eureka.server.renewalPercentThreshold = 0.85

#/**
#* The interval with which the threshold as specified in
#* {@link #getRenewalPercentThreshold()} needs to be updated.
#*
#* @return time in milliseconds indicating the interval.
#*/
#int getRenewalThresholdUpdateIntervalMs();
#eureka.server.renewalThresholdUpdateIntervalMs = 15 * MINUTES

#/**
#* The interval with which the information about the changes in peer eureka
#* nodes is updated. The user can use the DNS mechanism or dynamic
#* configuration provided by <a href="https://github.com/Netflix/archaius">Archaius</a> to
#* change the information dynamically.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return timer in milliseconds indicating the interval.
#*/
#int getPeerEurekaNodesUpdateIntervalMs();
#eureka.server.peerEurekaNodesUpdateIntervalMs = 10 * MINUTES

#/**
#* If set to true, the replicated data send in the request will be always compressed.
#* This does not define response path, which is driven by "Accept-Encoding" header.
#*/
#boolean shouldEnableReplicatedRequestCompression();
#eureka.server.enableReplicatedRequestCompression = false

#/**
#* Get the number of times the replication events should be retried with
#* peers.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the number of retries.
#*/
#int getNumberOfReplicationRetries();
#eureka.server.numberOfReplicationRetries = 5

#/**
#* Gets the interval with which the status information about peer nodes is
#* updated.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return time in milliseconds indicating the interval.
#*/
#int getPeerEurekaStatusRefreshTimeIntervalMs();
#eureka.server.peerEurekaStatusRefreshTimeIntervalMs = 30 * 1000

#/**
#* Gets the time to wait when the eureka server starts up unable to get
#* instances from peer nodes. It is better not to start serving rightaway
#* during these scenarios as the information that is stored in the registry
#* may not be complete.
#*
#* When the instance registry starts up empty, it builds over time when the
#* clients start to send heartbeats and the server requests the clients for
#* registration information.
#*
#* @return time in milliseconds.
#*/
#int getWaitTimeInMsWhenSyncEmpty();
#eureka.server.waitTimeInMsWhenSyncEmpty = 5 * MINUTES

#/**
#* Gets the timeout value for connecting to peer eureka nodes for
#* replication.
#*
#* @return timeout value in milliseconds.
#*/
#int getPeerNodeConnectTimeoutMs();
#eureka.server.peerNodeConnectTimeoutMs = 200

#/**
#* Gets the timeout value for reading information from peer eureka nodes for
#* replication.
#*
#* @return timeout value in milliseconds.
#*/
#int getPeerNodeReadTimeoutMs();
#eureka.server.peerNodeReadTimeoutMs = 200

#/**
#* Gets the total number of <em>HTTP</em> connections allowed to peer eureka
#* nodes for replication.
#*
#* @return total number of allowed <em>HTTP</em> connections.
#*/
#int getPeerNodeTotalConnections();
#eureka.server.peerNodeTotalConnections = 1000

#/**
#* Gets the total number of <em>HTTP</em> connections allowed to a
#* particular peer eureka node for replication.
#*
#* @return total number of allowed <em>HTTP</em> connections for a peer
#*         node.
#*/
#int getPeerNodeTotalConnectionsPerHost();
#eureka.server.peerNodeTotalConnectionsPerHost = 500

#/**
#* Gets the idle time after which the <em>HTTP</em> connection should be
#* cleaned up.
#*
#* @return idle time in seconds.
#*/
#int getPeerNodeConnectionIdleTimeoutSeconds();
#eureka.server.peerNodeConnectionIdleTimeoutSeconds = 30

#/**
#* Get the time for which the delta information should be cached for the
#* clients to retrieve the value without missing it.
#*
#* @return time in milliseconds
#*/
#long getRetentionTimeInMSInDeltaQueue();
#eureka.server.retentionTimeInMSInDeltaQueue = 3 * MINUTES

#/**
#* Get the time interval with which the clean up task should wake up and
#* check for expired delta information.
#*
#* @return time in milliseconds.
#*/
#long getDeltaRetentionTimerIntervalInMs();
#eureka.server.deltaRetentionTimerIntervalInMs = 30 * 1000

#/**
#* Get the time interval with which the task that expires instances should
#* wake up and run.
#*
#* @return time in milliseconds.
#*/
#long getEvictionIntervalTimerInMs();
#eureka.server.evictionIntervalTimerInMs = 60 * 1000

#/**
#* Get the timeout value for querying the <em>AWS</em> for <em>ASG</em>
#* information.
#*
#* @return timeout value in milliseconds.
#*/
#int getASGQueryTimeoutMs();
#eureka.server.aSGQueryTimeoutMs = 300

#/**
#* Get the time interval with which the <em>ASG</em> information must be
#* queried from <em>AWS</em>.
#*
#* @return time in milliseconds.
#*/
#long getASGUpdateIntervalMs();
#eureka.server.aSGUpdateIntervalMs = 5 * MINUTES

#/**
#* Get the expiration value for the cached <em>ASG</em> information
#*
#* @return time in milliseconds.
#*/
#long getASGCacheExpiryTimeoutMs();
#eureka.server.aSGCacheExpiryTimeoutMs = 10 * MINUTES # defaults to longer than the asg update interval

#/**
#* Gets the time for which the registry payload should be kept in the cache
#* if it is not invalidated by change events.
#*
#* @return time in seconds.
#*/
#long getResponseCacheAutoExpirationInSeconds();
#eureka.server.responseCacheAutoExpirationInSeconds = 180

#/**
#* Gets the time interval with which the payload cache of the client should
#* be updated.
#*
#* @return time in milliseconds.
#*/
#long getResponseCacheUpdateIntervalMs();
#eureka.server.responseCacheUpdateIntervalMs = 30 * 1000

#/**
#* The {@link com.netflix.eureka.registry.ResponseCache} currently uses a two level caching
#* strategy to responses. A readWrite cache with an expiration policy, and a readonly cache
#* that caches without expiry.
#*
#* @return true if the read only cache is to be used
#*/
#boolean shouldUseReadOnlyResponseCache();
#eureka.server.useReadOnlyResponseCache = true

#/**
#* Checks to see if the delta information can be served to client or not.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return true if the delta information is allowed to be served, false
#*         otherwise.
#*/
#boolean shouldDisableDelta();
#eureka.server.disableDelta=false

#/**
#* Get the idle time for which the status replication threads can stay
#* alive.
#*
#* @return time in minutes.
#*/
#long getMaxIdleThreadInMinutesAgeForStatusReplication();
#eureka.server.maxIdleThreadInMinutesAgeForStatusReplication = 10

#/**
#* Get the minimum number of threads to be used for status replication.
#*
#* @return minimum number of threads to be used for status replication.
#*/
#int getMinThreadsForStatusReplication();
#eureka.server.minThreadsForStatusReplication = 1

#/**
#* Get the maximum number of threads to be used for status replication.
#*
#* @return maximum number of threads to be used for status replication.
#*/
#int getMaxThreadsForStatusReplication();
#eureka.server.maxThreadsForStatusReplication = 1

#/**
#* Get the maximum number of replication events that can be allowed to back
#* up in the status replication pool.
#* <p>
#* Depending on the memory allowed, timeout and the replication traffic,
#* this value can vary.
#* </p>
#*
#* @return the maximum number of replication events that can be allowed to
#*         back up.
#*/
#int getMaxElementsInStatusReplicationPool();
#eureka.server.maxElementsInStatusReplicationPool = 10000

#/**
#* Checks whether to synchronize instances when timestamp differs.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return true, to synchronize, false otherwise.
#*/
#boolean shouldSyncWhenTimestampDiffers();
#eureka.server.syncWhenTimestampDiffers = true

#/**
#* Get the number of times that a eureka node would try to get the registry
#* information from the peers during startup.
#*
#* @return the number of retries
#*/
#int getRegistrySyncRetries();
#eureka.server.registrySyncRetries = 0

#/**
#* Get the wait/sleep time between each retry sync attempts, if the prev retry failed and there are
#* more retries to attempt.
#*
#* @return the wait time in ms between each sync retries
#*/
#long getRegistrySyncRetryWaitMs();
#eureka.server.registrySyncRetryWaitMs = 30 * 1000

#/**
#* Get the maximum number of replication events that can be allowed to back
#* up in the replication pool. This replication pool is responsible for all
#* events except status updates.
#* <p>
#* Depending on the memory allowed, timeout and the replication traffic,
#* this value can vary.
#* </p>
#*
#* @return the maximum number of replication events that can be allowed to
#*         back up.
#*/
#int getMaxElementsInPeerReplicationPool();
#eureka.server.maxElementsInPeerReplicationPool = 10000

#/**
#* Get the idle time for which the replication threads can stay alive.
#*
#* @return time in minutes.
#*/
#long getMaxIdleThreadAgeInMinutesForPeerReplication();
#eureka.server.maxIdleThreadAgeInMinutesForPeerReplication = 15

#/**
#* Get the minimum number of threads to be used for replication.
#*
#* @return minimum number of threads to be used for replication.
#*/
#int getMinThreadsForPeerReplication();
#eureka.server.minThreadsForPeerReplication = 5

#/**
#* Get the maximum number of threads to be used for replication.
#*
#* @return maximum number of threads to be used for replication.
#*/
#int getMaxThreadsForPeerReplication();
#eureka.server.maxThreadsForPeerReplication = 20

#/**
#* Get the minimum number of available peer replication instances
#* for this instance to be considered healthy. The design of eureka allows
#* for an instance to continue operating with zero peers, but that would not
#* be ideal.
#* <p>
#* The default value of -1 is interpreted as a marker to not compare
#* the number of replicas. This would be done to either disable this check
#* or to run eureka in a single node configuration.
#*
#* @return minimum number of available peer replication instances
#*         for this instance to be considered healthy.
#*/
#int getHealthStatusMinNumberOfAvailablePeers();
#eureka.server.minAvailableInstancesForPeerReplication = -1

#/**
#* Get the time in milliseconds to try to replicate before dropping
#* replication events.
#*
#* @return time in milliseconds
#*/
#int getMaxTimeForReplication();
#eureka.server.maxTimeForReplication = 30000

#/**
#* Checks whether the connections to replicas should be primed. In AWS, the
#* firewall requires sometime to establish network connection for new nodes.
#*
#* @return true, if connections should be primed, false otherwise.
#*/
#boolean shouldPrimeAwsReplicaConnections();
#eureka.server.primeAwsReplicaConnections = true

#/**
#* Checks to see if the delta information can be served to client or not for
#* remote regions.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return true if the delta information is allowed to be served, false
#*         otherwise.
#*/
#boolean shouldDisableDeltaForRemoteRegions();
#eureka.server.disableDeltaForRemoteRegions=false

#/**
#* Gets the timeout value for connecting to peer eureka nodes for remote
#* regions.
#*
#* @return timeout value in milliseconds.
#*/
#int getRemoteRegionConnectTimeoutMs();
#eureka.server.remoteRegionConnectTimeoutMs = 1000

#/**
#* Gets the timeout value for reading information from peer eureka nodes for
#* remote regions.
#*
#* @return timeout value in milliseconds.
#*/
#int getRemoteRegionReadTimeoutMs();
#eureka.server.remoteRegionReadTimeoutMs = 1000

#/**
#* Gets the total number of <em>HTTP</em> connections allowed to peer eureka
#* nodes for remote regions.
#*
#* @return total number of allowed <em>HTTP</em> connections.
#*/
#
#int getRemoteRegionTotalConnections();
#eureka.server.remoteRegionTotalConnections = 1000

#/**
#* Gets the total number of <em>HTTP</em> connections allowed to a
#* particular peer eureka node for remote regions.
#*
#* @return total number of allowed <em>HTTP</em> connections for a peer
#*         node.
#*/
#int getRemoteRegionTotalConnectionsPerHost();
#eureka.server.remoteRegionTotalConnectionsPerHost = 500

#/**
#* Gets the idle time after which the <em>HTTP</em> connection should be
#* cleaned up for remote regions.
#*
#* @return idle time in seconds.
#*/
#int getRemoteRegionConnectionIdleTimeoutSeconds();
#eureka.server.remoteRegionConnectionIdleTimeoutSeconds = 30

#/**
#* Indicates whether the content fetched from eureka server has to be
#* compressed for remote regions whenever it is supported by the server. The
#* registry information from the eureka server is compressed for optimum
#* network traffic.
#*
#* @return true, if the content need to be compressed, false otherwise.
#*/
#boolean shouldGZipContentFromRemoteRegion();
#eureka.server.gZipContentFromRemoteRegion = true

#/**
#* Get a map of region name against remote region discovery url.
#*
#* @return - An unmodifiable map of remote region name against remote region discovery url. Empty map if no remote
#* region url is defined.
#*/
#Map<String, String> getRemoteRegionUrlsWithName();
#eureka.server.remoteRegionUrlsWithName.{key}={value}

#/**
#* Get the list of remote region urls.
#* @return - array of string representing {@link java.net.URL}s.
#* @deprecated Use {@link #getRemoteRegionUrlsWithName()}
#*/
#String[] getRemoteRegionUrls();
#eureka.server.remoteRegionUrl=[]

#/**
#* Returns a list of applications that must be retrieved from the passed remote region. <br/>
#* This list can be <code>null</code> which means that no filtering should be applied on the applications
#* for this region i.e. all applications must be returned. <br/>
#* A global whitelist can also be configured which can be used when no setting is available for a region, such a
#* whitelist can be obtained by passing <code>null</code> to this method.
#*
#* @param regionName Name of the region for which the application whitelist is to be retrieved. If null a global
#*                   setting is returned.
#*
#* @return A set of application names which must be retrieved from the passed region. If <code>null</code> all
#* applications must be retrieved.
#*/
#@Nullable
#Set<String> getRemoteRegionAppWhitelist(@Nullable String regionName);
#eureka.server.remoteRegionAppWhitelist.{key}={value}

#/**
#* Get the time interval for which the registry information need to be fetched from the remote region.
#* @return time in seconds.
#*/
#int getRemoteRegionRegistryFetchInterval();
#eureka.server.remoteRegionRegistryFetchInterval = 30

#/**
#* Size of a thread pool used to execute remote region registry fetch requests. Delegating these requests
#* to internal threads is necessary workaround to https://bugs.openjdk.java.net/browse/JDK-8049846 bug.
#*/
#int getRemoteRegionFetchThreadPoolSize();
#eureka.server.emoteRegionFetchThreadPoolSize = 20

#/**
#* Gets the fully qualified trust store file that will be used for remote region registry fetches.
#* @return
#*/
#String getRemoteRegionTrustStore();
#eureka.server.remoteRegionTrustStore = ""

#/**
#* Get the remote region trust store's password.
#*/
#String getRemoteRegionTrustStorePassword();
#eureka.server.remoteRegionTrustStorePassword = "changeit"

#/**
#* Old behavior of fallback to applications in the remote region (if configured) if there are no instances of that
#* application in the local region, will be disabled.
#*
#* @return {@code true} if the old behavior is to be disabled.
#*/
#boolean disableTransparentFallbackToOtherRegion();
#eureka.server.disableTransparentFallbackToOtherRegion=false

#/**
#* Indicates whether the replication between cluster nodes should be batched for network efficiency.
#* @return {@code true} if the replication needs to be batched.
#*/
#boolean shouldBatchReplication();
#eureka.server.batchReplication=false

#/**
#* Indicates whether the eureka server should log/metric clientAuthHeaders
#* @return {@code true} if the clientAuthHeaders should be logged and/or emitted as metrics
#*/
#boolean shouldLogIdentityHeaders();
#eureka.server.logIdentityHeaders = true

#/**
#* Indicates whether the rate limiter should be enabled or disabled.
#*/
#boolean isRateLimiterEnabled();
#eureka.server.rateLimiterEnabled = false

#/**
#* Indicate if rate limit standard clients. If set to false, only non standard clients
#* will be rate limited.
#*/
#boolean isRateLimiterThrottleStandardClients();
#eureka.server.rateLimiterThrottleStandardClients = false

#/**
#* A list of certified clients. This is in addition to standard eureka Java clients.
#*/
#Set<String> getRateLimiterPrivilegedClients();
#eureka.server.rateLimiterPrivilegedClients=[]

#/**
#* Rate limiter, token bucket algorithm property. See also {@link #getRateLimiterRegistryFetchAverageRate()}
#* and {@link #getRateLimiterFullFetchAverageRate()}.
#*/
#int getRateLimiterBurstSize();
#eureka.server.rateLimiterBurstSize = 10

#/**
#* Rate limiter, token bucket algorithm property. Specifies the average enforced request rate.
#* See also {@link #getRateLimiterBurstSize()}.
#*/
#int getRateLimiterRegistryFetchAverageRate();
#eureka.server.rateLimiterRegistryFetchAverageRate = 500

#/**
#* Rate limiter, token bucket algorithm property. Specifies the average enforced request rate.
#* See also {@link #getRateLimiterBurstSize()}.
#*/
#int getRateLimiterFullFetchAverageRate();
#eureka.server.rateLimiterFullFetchAverageRate = 100

#/**
#* Name of the Role used to describe auto scaling groups from third AWS accounts.
#*/
#String getListAutoScalingGroupsRoleName();
#eureka.server.listAutoScalingGroupsRoleName = "ListAutoScalingGroups"

#/**
#* @return the class name of the full json codec to use for the server. If none set a default codec will be used
#*/
#String getJsonCodecName();
#eureka.server.jsonCodecName=

#/**
#* @return the class name of the full xml codec to use for the server. If none set a default codec will be used
#*/
#String getXmlCodecName();
#eureka.server.xmlCodecName=

#/**
#* Get the configured binding strategy EIP or Route53.
#* @return the configured binding strategy
#*/
#AwsBindingStrategy getBindingStrategy();
#eureka.server.bindingStrategy = AwsBindingStrategy.EIP

#/**
#*
#* @return the ttl used to set up the route53 domain if new
#*/
#long getRoute53DomainTTL();
#eureka.server.route53DomainTTL = 30

#/**
#* Gets the number of times the server should try to bind to the candidate
#* Route53 domain.
#*
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the number of times the server should try to bind to the
#*         candidate Route53 domain.
#*/
#int getRoute53BindRebindRetries();
#eureka.server.route53BindRebindRetries = 3

#/**
#* Gets the interval with which the server should check if the Route53 domain is bound
#* and should try to bind in the case if it is already not bound.
#* <p>
#* <em>The changes are effective at runtime.</em>
#* </p>
#*
#* @return the time in milliseconds.
#*/
#int getRoute53BindingRetryIntervalMs();
#eureka.server.route53BindingRetryIntervalMs = 5 * MINUTES

#/**
#* To avoid configuration API pollution when trying new/experimental or features or for the migration process,
#* the corresponding configuration can be put into experimental configuration section.
#*
#* @return a property of experimental feature
#*/
#String getExperimental(String name);
#eureka.server.experimental.{name}=null